# fastener.py

import os
from glob import glob
from uuid import UUID
import json
import datetime
from abc import ABC, abstractmethod
from fractions import Fraction
from decimal import Decimal

"""
The Fastener class is an abstract class that represents an imaged fastener that
has been processed.
"""


class Fastener(ABC):
    # class constants; should not be mutated at runtime
    VALID_STATUS = ["ok", "stale"]
    VALID_WORLD = ["real", "sim"]
    VALID_PLATFORM_VERSION = {"real": [1.0], "sim": [1.0]}
    VALID_PLATFORM_CONFIGURATION = {"real": [0], "sim": [0]}
    VALID_MEASUREMENT_SYSTEM = ["metric", "imperial"]
    VALID_FASTENER_TYPE = ["screw", "nut", "washer"]
    VALID_ROCESSING = [""]
    DATETIME_TEMPLATE = "%Y-%m-%d %H:%M:%S.%f"
    INCH_TO_MM = 25.4
    FT_IN_MM = 12 * INCH_TO_MM

    # instance attributes for Fastener types
    path: str
    uuid: str
    status: str
    world: str
    platform_version: str
    platform_configuration: str
    date: str
    time: str
    measurement_system: str
    fastener_type: str
    processing: str

    """
    Constructs a Fastener object.

    Args:
        metadata: A *flat* dictionary that consists at least the following keys:
            'uuid' is a UUID4 that identifies the imaged fastener instance
            'status' is a status indicator; must be in Fastener.VALID_STATUS
            'world' indicates the data source; must be in Fastener.VALID_WORLD
            'platform_version' is the version number of the imagaging platform;
                must be in Fastener.VALID_PLATFORM_VERSION for the associated world
            'platform_configuration' is the configuration of the given imaging platform;
                must be in Fastener.VALID_PLATFORM_CONFIGURATION for the associated world
            'date' is the date the fastener was imaged in 'yyyyy-mm-dd' format
            'time' is the time the fastener was imaged in 'hh:mm:ss.ms' format
                (ISO with milliseconds resolution)
            'measurement_system' must be in Fastener.VALID_MEASUREMENT_SYSTEM
            'fastener_type' must be in Fastener.VALID_FASTENER_TYPE
            'processing' indicates the algorithm by which this fastener was processed;
                must be in Fastener.PROCESSING
        path: Path to the image set of the fastener or None
        trusted: A flag used to bypass any validation for trusted data; should only be used
            if the data was generated by this class or any subclass. 

    Returns:
        None

    Raises:
        KeyError: A required key is missing in metadata.
        ValueError: A required key has an invalid value.
    """

    def __init__(self, metadata: dict, path: str = None, trusted: bool = False):
        self.path = path
        self.uuid = metadata["uuid"]
        self.status = metadata["status"]
        self.world = metadata["world"]
        self.platform_version = metadata["platform_version"]
        self.platform_configuration = metadata["platform_configuration"]
        self.date = metadata["date"]
        self.time = metadata["time"]
        self.measurement_system = metadata["measurement_system"]
        self.fastener_type = metadata["fastener_type"]
        self.processing = metadata["processing"]
        self.topdown_included = metadata["topdown_included"]
        self.sideon_included = metadata["sideon_included"]
        self.number_sideon = metadata["number_sideon"]

        if not trusted:
            if not Fastener.validate_path(self.path):
                raise ValueError(
                    "path is either not a directory or does not contain a json file"
                )
            if not Fastener.validate_uuid(self.uuid):
                raise ValueError("uuid is not valid")
            if not Fastener.validate_status(self.status):
                raise ValueError("status is not valid")
            if not Fastener.validate_world(self.world):
                raise ValueError("world is not valid")
            if not Fastener.validate_platform_version(
                self.world, self.platform_version
            ):
                raise ValueError("platform version is not valid")
            if not Fastener.validate_platform_configuration(
                self.world, self.platform_configuration
            ):
                raise ValueError("platform configuration is not valid")
            if not Fastener.validate_datetime(f"{self.date} {self.time}"):
                raise ValueError("date or time is not valid")
            if not Fastener.validate_measurement_system(self.measurement_system):
                raise ValueError("measurement system is not valid")
            if not Fastener.validate_fastener_type(self.fastener_type):
                raise ValueError("fastener type is not valid")
            if not Fastener.validate_processing(self.processing):
                raise ValueError("processing is not valid")
            if not isinstance(self.topdown_included, bool):
                raise ValueError("topdown_included is not valid")
            if not isinstance(self.sideon_included, bool):
                raise ValueError("sideon_included is not valid")
            if not isinstance(self.number_sideon, int):
                raise ValueError("number_sideon is not valid")

        if path is None:
            self._populate_attributes_flat_dict(metadata)
        else:
            self._populate_attributes_nested_dict(metadata)
        self._validate_and_process_attributes(trusted=trusted)

    """
    Writes the json representation of this fastener to a give json file. 

    Args:
        json_file_path: A path to the file to be written.

    Returns:
        None
    """

    def to_json(self, json_file_path: str):
        with open(json_file_path, "w") as f:
            metadata = dict()
            metadata["uuid"] = self.uuid
            metadata["status"] = self.status
            metadata["world"] = self.world
            metadata["platform_version"] = self.platform_version
            metadata["platform_configuration"] = self.platform_configuration
            metadata["date"] = self.date
            metadata["time"] = self.time
            metadata["fastener_type"] = self.fastener_type
            metadata["measurement_system"] = self.measurement_system
            metadata["processing"] = self.processing
            metadata["topdown_included"] = self.topdown_included
            metadata["sideon_included"] = self.sideon_included
            metadata["number_sideon"] = self.number_sideon
            metadata["attributes"] = self._get_attributes()
            json.dump(metadata, f)

    """
    Returns a dict of the attributes of the fastener.

    Returns:
        None
    """

    @abstractmethod
    def _get_attributes(self):
        pass

    """
    Validates and processes all the attributes of the fastener. 

    Args:
        trusted: A flag used to bypass any validation for trusted data; 
            should only be used if the data was generated by this class or any subclass. 

    Returns:
        None
    """

    @abstractmethod
    def _validate_and_process_attributes(self, trusted: bool = False):
        pass

    """
    Populates the fastener's instance attributes given a flat dictionary (no nesting)

    Args:
        metadata: A dictionary containing fastener attributes that is flat, i.e., 
            all attributes can be accessed by subscribing to metadata directly. 
            Necessary keys depend on concrete implementation.

    Returns:
        None
    """

    @abstractmethod
    def _populate_attributes_flat_dict(self, metadata):
        pass

    """
    Populates the fastener's instance attributes given a nested dictionary

    Args:
        metadata: A dictionary containing fastener attributes within metadata['attributes'].
            Necessary keys in nested dict depend on concrete implementation. 

    Returns:
        None
    """

    @abstractmethod
    def _populate_attributes_nested_dict(self, metadata):
        pass

    @staticmethod
    def validate_path(prospect: str):
        if prospect is None:
            return True
        if os.path.isdir(prospect):
            json_files = glob(os.path.join(prospect, "*.json"))
            print(json_files)
            return len(json_files) == 1
        else:
            return False

    @staticmethod
    def validate_uuid(prospect: str):
        try:
            UUID(prospect, version=4)
            return True
        except ValueError:
            return False

    @staticmethod
    def validate_status(prospect):
        return prospect in Fastener.VALID_STATUS

    @staticmethod
    def validate_world(prospect):
        return prospect in Fastener.VALID_WORLD

    @staticmethod
    def validate_platform_version(prospect_world, prospect_version):
        if prospect_world in Fastener.VALID_PLATFORM_VERSION:
            return prospect_version in Fastener.VALID_PLATFORM_VERSION[prospect_world]
        else:
            return False

    @staticmethod
    def validate_platform_configuration(prospect_world, prospect_config):
        if prospect_world in Fastener.VALID_PLATFORM_CONFIGURATION:
            return (
                prospect_config in Fastener.VALID_PLATFORM_CONFIGURATION[prospect_world]
            )
        else:
            return False

    @staticmethod
    def validate_datetime(prospect):
        try:
            datetime.datetime.strptime(prospect, Fastener.DATETIME_TEMPLATE)
            return True
        except ValueError:
            return False

    @staticmethod
    def validate_measurement_system(prospect):
        return prospect in Fastener.VALID_MEASUREMENT_SYSTEM

    @staticmethod
    def validate_fastener_type(prospect):
        return prospect in Fastener.VALID_FASTENER_TYPE

    @staticmethod
    def validate_processing(prospect):
        return prospect in Fastener.VALID_ROCESSING

    @staticmethod
    def validate_fraction_str(fraction: str):
        try:
            Fraction(fraction)
            return True
        except ValueError:
            return False

    @staticmethod
    def validate_decimal_str(decimal: str):
        try:
            Decimal(decimal)
            return True
        except Exception:
            return False

    def __str__(self):
        return str(vars(self))


"""
The Screw class is subclass of Fastener that represents an imaged screw that has been processed. 
"""


class Screw(Fastener):
    # class constants; should not be mutated at runtime
    VALID_LENGTH_N = (0.0001, 12 * Fastener.INCH_TO_MM)
    VALID_PITCH_N = (0.0001, 1 * Fastener.INCH_TO_MM)
    VALID_DIAMETER_N = (0.0001, 1 * Fastener.INCH_TO_MM)
    VALID_HEAD = ["socket"]
    VALID_DRIVE = [
        "hex",
        "external hex",
        "jis",
        "slotted",
        "torx",
        "torx plus",
        "square",
        "phillips",
    ]
    VALID_DIRECTION = ["clockwise", "counter-clockwise"]
    VALID_FINISH = ["plastic", "brass", "stainless steel", "aluminium", "black oxide"]

    # instance attributes
    length: str
    diameter: str
    pitch: str
    length_n: float
    diameter_n: float
    pitch_n: float
    head: str
    drive: str
    direction: str
    finish: str

    """
    Constructs a Screw object from a dictionary. 

    Args:
        metadata: A *flat* dictionary that consists all keys required to construct a Fastener, and: 
            'length' is the length of the screw, either as a string fraction
                (imperial) or a string decimal (metric)
            'diameter' is the diameter of the screw as a string decimal
            'pitch' is the pitch of the screw as a string decimal
            'head' is the external head geometry of the screw; must be in Screw.VALID_HEAD
            'drive' is the inset drive geometry of the screw; must be in Screw.VALID_DRIVE
            'direction' refers to whether the screw is left-handed or right-handed;
                must be in Screw.VALID_DIRECTION
            'finish' refers to the visual finish of the screw;
                must be in Screw.VALID_FINISH
        path: Path to the image set of the fastener or None
        trusted: A flag used to bypass any validation for trusted data; 
            should only be used if the data was generated by this class or any subclass. 

    Returns:
        Screw

    Raises:
        KeyError: A required key is missing in metadata.
        ValueError: A required key has an invalid value.
    """

    def __init__(self, metadata: dict, path=None, trusted=False):
        super().__init__(metadata, path=path, trusted=trusted)

    """
    Constructs a Screw object from a dictionary. 

    Args:
        metadata: A *flat* dictionary that consists all keys required to construct a Fastener, and: 
            'length' is the length of the screw, either as a string fraction (imperial) or a string decimal (metric)
            'diameter' is the diameter of the screw as a string decimal
            'pitch' is the pitch of the screw as a string decimal
            'head' is the external head geometry of the screw; must be in Screw.VALID_HEAD
            'drive' is the inset drive geometry of the screw; must be in Screw.VALID_DRIVE
            'direction' refers to whether the screw is left-handed or right-handed; must be in Screw.VALID_DIRECTION
            'finish' refers to the visual finish of the screw; must be in Screw.VALID_FINISH
    Returns:
        Screw

    Raises:
        KeyError: A required key is missing in metadata.
        ValueError: A required key has an invalid value.
    """

    @staticmethod
    def from_dict(metadata: dict):
        return Screw(metadata)

    """
    Constructs a Screw from a json file.

    Args:
        path: The path to the json file. 

    Returns:
        Screw

    Raises:
        ValueError: The path does not exist or the json data is invalid. 
    """

    @staticmethod
    def from_json(path: str, trusted: bool = False):
        if not trusted:
            if not Fastener.validate_path(path):
                raise ValueError(
                    "path is either not a directory or does not contain a json metadata file"
                )
        metadata_path = glob(os.path.join(path, "*.json"))[0]
        with open(metadata_path, "r") as f:
            metadata = json.load(f)
            return Screw(metadata, path=path, trusted=trusted)

    def _get_attributes(self):
        return {
            "length": self.length,
            "diameter": self.diameter,
            "pitch": self.pitch,
            "head": self.head,
            "drive": self.drive,
            "direction": self.direction,
            "finish": self.finish,
        }

    def _populate_attributes_flat_dict(self, metadata):
        self.head = metadata["head"]
        self.drive = metadata["drive"]
        self.direction = metadata["direction"]
        self.finish = metadata["finish"]
        self.length = metadata["length"]
        self.diameter = metadata["diameter"]
        self.pitch = metadata["pitch"]

    def _populate_attributes_nested_dict(self, metadata):
        self.head = metadata["attributes"]["head"]
        self.drive = metadata["attributes"]["drive"]
        self.direction = metadata["attributes"]["direction"]
        self.finish = metadata["attributes"]["finish"]
        self.length = metadata["attributes"]["length"]
        self.diameter = metadata["attributes"]["diameter"]
        self.pitch = metadata["attributes"]["pitch"]

    def _validate_and_process_attributes(self, trusted: bool = False):
        if not trusted:
            if not Screw.validate_head(self.head):
                raise ValueError("screw head is not valid")
            if not Screw.validate_drive(self.drive):
                raise ValueError("screw drive is not valid")
            if not Screw.validate_direction(self.direction):
                raise ValueError("screw direction is not valid")
            if not Screw.validate_finish(self.finish):
                raise ValueError("screw finish is not valid")
            if not Screw.validate_length(self.measurement_system, self.length):
                raise ValueError("screw length is not valid")
            if not Screw.validate_diameter(self.measurement_system, self.diameter):
                raise ValueError("screw diameter is not valid")
            if not Screw.validate_pitch(self.measurement_system, self.pitch):
                raise ValueError("screw pitch is not valid")

        if self.measurement_system == "metric":
            self.length_n = Screw.decimal_str_to_float(self.length)
            self.diameter_n = Screw.decimal_str_to_float(self.diameter)
            self.pitch_n = Screw.decimal_str_to_float(self.pitch)
        elif self.measurement_system == "imperial":
            self.length_n = (
                Screw.fraction_str_to_float(self.length) * Fastener.INCH_TO_MM
            )
            self.diameter_n = (
                Screw.decimal_str_to_float(self.diameter) * Fastener.INCH_TO_MM
            )
            self.length_n = Screw.decimal_str_to_float(self.pitch) * Fastener.INCH_TO_MM

    @staticmethod
    def fraction_str_to_float(inch: str):
        return float(Fraction(inch))

    @staticmethod
    def decimal_str_to_float(mm: str):
        return float(Decimal(mm))

    @staticmethod
    def validate_head(prospect: str):
        return prospect in Screw.VALID_HEAD

    @staticmethod
    def validate_drive(prospect: str):
        return prospect in Screw.VALID_DRIVE

    @staticmethod
    def validate_direction(prospect: str):
        return prospect in Screw.VALID_DIRECTION

    @staticmethod
    def validate_finish(prospect: str):
        return prospect in Screw.VALID_FINISH

    @staticmethod
    def validate_length(prospect_measurement_system, prospect_length):
        if prospect_measurement_system == "metric":
            if Fastener.validate_decimal_str(prospect_length):
                l = float(Decimal(prospect_length))
                return l >= Screw.VALID_LENGTH_N[0] and l <= Screw.VALID_LENGTH_N[1]
        elif prospect_measurement_system == "imperial":
            if Fastener.validate_fraction_str(prospect_length):
                l = float(Decimal(prospect_length)) * Fastener.INCH_TO_MM
                return l >= Screw.VALID_LENGTH_N[0] and l <= Screw.VALID_LENGTH_N[1]
        return False

    @staticmethod
    def validate_diameter(prospect_measurement_system, prospect_diameter):
        if prospect_measurement_system == "metric":
            if Fastener.validate_decimal_str(prospect_diameter):
                l = float(Decimal(prospect_diameter))
                return l >= Screw.VALID_DIAMETER_N[0] and l <= Screw.VALID_DIAMETER_N[1]
        elif prospect_measurement_system == "imperial":
            if Fastener.validate_decimal_str(prospect_diameter):
                l = float(Decimal(prospect_diameter)) * Fastener.INCH_TO_MM
                return l >= Screw.VALID_DIAMETER_N[0] and l <= Screw.VALID_DIAMETER_N[1]
        return False

    @staticmethod
    def validate_pitch(prospect_measurement_system, prospect_pitch):
        if prospect_measurement_system == "metric":
            if Fastener.validate_decimal_str(prospect_pitch):
                l = float(Decimal(prospect_pitch))
                return l >= Screw.VALID_PITCH_N[0] and l <= Screw.VALID_PITCH_N[1]
        elif prospect_measurement_system == "imperial":
            if Fastener.validate_decimal_str(prospect_pitch):
                l = float(Decimal(prospect_pitch)) * Fastener.INCH_TO_MM
                return l >= Screw.VALID_PITCH_N[0] and l <= Screw.VALID_PITCH_N[1]
        return False


class Nut(Fastener):
    diameter: str
    pitch: str
    direction: str
    finish: str

    def __init__(self, path: str):
        super().__init__(path)

    def _populate_attributes(self, metadata):
        self.diameter = metadata["attributes"]["diameter"]
        self.pitch = metadata["attributes"]["pitch"]
        self.direction = metadata["attributes"]["direction"]
        self.finish = metadata["attributes"]["finish"]


class Washer(Fastener):
    inner_diameter: str
    outer_diameter: str
    thickness: str
    finish: str

    def __init__(self, path: str):
        super().__init__(path)

    def _populate_attributes(self, metadata):
        self.inner_diameter = metadata["attributes"]["inner_diameter"]
        self.outer_diameter = metadata["attributes"]["outer_diameter"]
        self.thickness = metadata["attributes"]["thickness"]
        self.finish = metadata["attributes"]["finish"]
